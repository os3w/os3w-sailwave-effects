{"version":3,"file":"CountOnlyQualifyingRaces.js","sources":["../src/results/result.ts","../src/results/scoring.ts","../src/html/helpers.ts","../src/html/parse-group-table.ts","../src/html/group.ts","../src/html/parse-results-html.ts","../src/effect/scoring.ts","../src/effect/count-only-qualifying-races.ts"],"sourcesContent":["export const DNC = 'DNC';\nexport const DNQ = 'DNQ';\n\nexport type Result = SailedResult | NotSailedResult;\n\nexport interface NotSailedResult {\n  element: HTMLElement;\n  html: string;\n  isNotSailed: true;\n}\n\nexport interface SailedResult {\n  element: HTMLElement;\n  html: string;\n  isDiscard: boolean;\n  score: number;\n  code: string | null;\n}\n\nconst dncCodes = [DNC, 'OOD'];\n\n/**\n * Test whether a result code implies that the competitor came to the starting\n * area.\n *\n * @param code A result code (or null for no code which implies that the\n *             competitor did come).\n */\nexport const cameToStartingArea = (code: string | null) =>\n  code === null || !dncCodes.includes(code);\n\n/**\n * Check if a result is a sailed result.\n *\n * @param result The result to check.\n * @returns The result if sailed, otherwise false.\n */\nexport const checkIsSailedResult = (result: Result): SailedResult | false =>\n  !result || (result as unknown as NotSailedResult).isNotSailed === true\n    ? false\n    : (result as SailedResult);\n","import { DNQ, checkIsSailedResult } from './result';\n\nimport type { GroupCompetitor } from './scored-group/competitor';\nimport type { Group } from './scored-group/group';\n\n/*\nexport interface ComparableResult {\n  score: number;\n}\n\nexport interface ComparableResults {\n  net: number;\n  results: ComparableResult[];\n}\n*/\n\nexport const applyDiscardsAndCalculateTotals = (group: Group) => {\n  for (const competitor of group.competitors) {\n    // Calculate the number of discards allowed and collect the scores for\n    // each race.\n    let discardsAllowed = 0;\n    let totalScoreTimesTen = 0;\n    const scores = [];\n\n    for (const result of competitor.results) {\n      const sailedResult = checkIsSailedResult(result);\n\n      if (!sailedResult) {\n        // Still add the score so we get the index right but make sure it is\n        // the last to be discarded.\n        scores.push(-Infinity);\n        continue;\n      }\n\n      const { isDiscard, score } = sailedResult;\n      if (isDiscard) {\n        // Count the number allowed and then forget it.\n        ++discardsAllowed;\n        sailedResult.isDiscard = false;\n      }\n      totalScoreTimesTen += Math.round(score * 10);\n      scores.push(score);\n    }\n\n    // Get which results to discard.\n    const discardIndexes = getDiscardIndexes(scores, discardsAllowed);\n\n    // Mark the appropriate races.\n    let netScoreTimesTen = totalScoreTimesTen;\n    for (const index of discardIndexes) {\n      const sailedResult = checkIsSailedResult(competitor.results[index]);\n      // We cannot discard a race that has not been sailed.\n      if (!sailedResult) continue;\n      sailedResult.isDiscard = true;\n      netScoreTimesTen -= Math.round(sailedResult.score * 10);\n    }\n\n    // Set the totals for the competitor and we are done.\n    competitor.total = totalScoreTimesTen / 10;\n    competitor.net = netScoreTimesTen / 10;\n  }\n};\n\n/**\n * Compare series results for two competitors in a scored group.\n *\n * @param a First competitor's race scores.\n * @param b Second competitor's race scores.\n * @returns\n */\nexport const compareSeriesResults = (\n  a: GroupCompetitor,\n  b: GroupCompetitor,\n): number => {\n  // If only one is DNQ it is easy.\n  if (a.rank === DNQ) {\n    if (b.rank !== DNQ) {\n      return 1;\n    }\n  } else if (b.rank === DNQ) {\n    return -1;\n  }\n  // If the net scores are different it is easy.\n  const difference = a.net - b.net;\n  if (difference) return difference;\n  return 0;\n};\n\n/**\n * Get the indexes of scores to discard.\n *\n * The indexes are in order of applying the discard algorithm so the index of\n * the highest value is returned first; for equal values the earlier index is\n * returned first.\n *\n * @param scores\n * @param number\n * @returns\n */\nexport const getDiscardIndexes = (\n  scores: number[],\n  number: number,\n): number[] => {\n  if (number < 1) return [];\n\n  // Sort the scores so we know what to discard.\n  const sorted = scores.slice().sort((a: number, b: number) => a - b);\n  const scoresToDiscard = sorted.slice(-number).reverse();\n  const discards = [];\n\n  let lastScore = NaN;\n  let lastIndex = NaN;\n  for (const score of scoresToDiscard) {\n    if (score === lastScore) {\n      lastIndex = scores.indexOf(score, lastIndex + 1);\n      discards.push(lastIndex);\n    } else {\n      lastIndex = scores.indexOf(score);\n      lastScore = score;\n      discards.push(lastIndex);\n    }\n  }\n  return discards;\n};\n\nexport const recalculateGroupRankings = (group: Group) => {\n  // console.log('Before', JSON.parse(JSON.stringify(group.competitors)));\n  // Sort into the new rank order.\n  group.competitors.sort(compareSeriesResults);\n\n  // Update the rank for each competitor.\n  let rank = 0;\n  for (const competitor of group.competitors) {\n    ++rank;\n    if (competitor.rank === DNQ) break;\n    competitor.rank = rank;\n  }\n  // console.log('After', JSON.parse(JSON.stringify(group.competitors)));\n};\n\nexport const scoreGroup = (group: Group) => {\n  applyDiscardsAndCalculateTotals(group);\n  recalculateGroupRankings(group);\n};\n","import type { SailedResult } from '../results';\n\n/**\n * Convert a (possibly null) string to a numerical score.\n *\n * @param text the displayed score.\n * @returns the score.\n */\nexport const parseValue = (text: string | null): number => {\n  return text === null ? 0 : parseFloat(text);\n};\n\nexport const formatOrdinal = (n: number): string => {\n  let ordinal = 'th';\n  switch (n % 10) {\n    case 1:\n      if (n % 100 !== 11) ordinal = 'st';\n      break;\n    case 2:\n      if (n % 100 !== 12) ordinal = 'nd';\n      break;\n    case 3:\n      if (n % 100 !== 13) ordinal = 'rd';\n      break;\n  }\n  return n + ordinal;\n};\n\n/**\n *\n * @param result\n */\nexport const formatSailedResult = ({\n  code,\n  isDiscard,\n  score,\n}: SailedResult) => {\n  // Sailwave Effects import breaks on template strings so don't use them.\n  // const text = code ? `${formatScore(score)} ${code}` : formatScore(score);\n  // return isDiscard ? `(${text})` : text;\n  const text = code ? formatScore(score) + ' ' + code : formatScore(score);\n  return isDiscard ? '(' + text + ')' : text;\n};\n\nexport const formatScore = (score: number) => score.toFixed(1);\n","import { cameToStartingArea, DNQ } from '../results';\n\nimport { parseValue } from './helpers';\n\nimport type {\n  NotSailedResult,\n  Result,\n  SailedResult,\n  GroupCompetitor,\n} from '../results';\n\nimport type { Column } from './column';\n\nexport class GroupTableParser {\n  competitors: GroupCompetitor[] = [];\n  columns: Column[] = [];\n  raceCount = 0;\n  qualifiedCount = 0;\n\n  parse(tableElement: Element): this {\n    for (const node of tableElement.children) {\n      switch (node.nodeName) {\n        case 'COLGROUP':\n          this.parseColGroup(node as HTMLElement);\n          break;\n\n        // Don't bother looking at the headings.\n        // case 'THEAD':\n\n        case 'TBODY':\n          this.parseSummaryRows(node as HTMLElement);\n          break;\n      }\n    }\n    return this;\n  }\n\n  /**\n   * Parse the `<colgroup>` of a results table.\n   *\n   * @param parent The `<colgroup>` node.\n   * @returns The parsed columns.\n   */\n  protected parseColGroup(parent: HTMLElement): void {\n    for (const node of parent.children) {\n      // Skip any unexpected nodes.\n      if (node.nodeName !== 'COL') continue;\n\n      const { className } = node;\n      switch (className) {\n        case 'rank':\n        case 'total':\n        case 'nett':\n          this.columns.push({ type: className });\n          break;\n        case 'race':\n          this.columns.push({ type: className, index: this.raceCount });\n          ++this.raceCount;\n          break;\n        default:\n          this.columns.push({ type: 'label', name: className });\n          break;\n      }\n    }\n  }\n\n  /**\n   * Parse the score element.\n   *\n   * @param element td element with the score.\n   * @returns\n   */\n  protected parseRaceScore(element: HTMLElement): Result {\n    const html = element.innerHTML;\n    if (html === '&nbsp;') {\n      return { element, html, isNotSailed: true } as NotSailedResult;\n    }\n    const { isDiscard, score, code } = parseRaceScore(html);\n    return {\n      element,\n      html,\n      isDiscard,\n      score,\n      code,\n    } as SailedResult;\n  }\n\n  /**\n   * Parse a competitor's summary row in a results table.\n   *\n   * @param parent The `<tr>` node.\n   * @returns The parsed columns.\n   */\n  protected parseSummaryRow(parent: HTMLElement): GroupCompetitor {\n    const competitor: GroupCompetitor = {\n      rank: NaN,\n      net: NaN,\n      total: NaN,\n      results: [],\n      // elements {},\n    };\n    competitor.elements = { competitor: parent };\n\n    // Column index.\n    let colIndex = 0;\n\n    for (const node of parent.children) {\n      // Skip any unexpected nodes.\n      if (node.nodeName !== 'TD') continue;\n\n      const column = this.columns[colIndex];\n      ++colIndex;\n      switch (column.type) {\n        case 'rank':\n          competitor.elements.rank = node;\n          competitor.rank = parseRank(node.textContent);\n          if (competitor.rank !== DNQ) {\n            ++this.qualifiedCount;\n          }\n          break;\n        case 'total':\n          competitor.elements.total = node;\n          competitor.total = parseValue(node.textContent);\n          break;\n        case 'nett':\n          competitor.elements.net = node;\n          competitor.net = parseValue(node.textContent);\n          break;\n        case 'race':\n          competitor.results[column.index] = this.parseRaceScore(\n            node as HTMLElement,\n          );\n        // Ignore labels for now.\n        // case 'label':\n      }\n    }\n    return competitor;\n  }\n\n  /**\n   * Parse a competitor's summary row in a results table.\n   *\n   * @param parent The `<tbody>` node.\n   * @returns The parsed columns.\n   */\n  protected parseSummaryRows(parent: HTMLElement): void {\n    for (const node of parent.children) {\n      // Skip any unexpected nodes.\n      if (node.nodeName !== 'TR' || !node.classList.contains('summaryrow')) {\n        continue;\n      }\n\n      this.competitors.push(this.parseSummaryRow(node as HTMLElement));\n    }\n  }\n}\n\n/**\n * Parse a displayed rank value (e.g. '1st') to its numerical value.\n *\n * @param text The displayed rank.\n * @returns The numerical value of the rank, or DNQ.\n */\nexport const parseRank = (text: string | null): number | 'DNQ' => {\n  if (text === null || text === DNQ) return DNQ;\n  return parseFloat(text);\n};\n\n/**\n * Parse text containing a (possibly discarded) score, possibly with a code.\n * @param text\n * @returns\n */\nexport const parseRaceScore = (text: string) => {\n  const isDiscard = text.charAt(0) === '(';\n  const rawText = isDiscard ? text.slice(1, -1) : text;\n  const score = parseValue(rawText);\n  // If we have a score then we need to check for a code.\n  let code;\n  if (Number.isNaN(score)) {\n    code = rawText.length > 0 ? rawText : null;\n  } else {\n    const spacePos = rawText.indexOf(' ');\n    code = spacePos < 0 ? null : rawText.slice(spacePos + 1);\n  }\n  const isCts = code === null ? true : cameToStartingArea(code);\n  return { isCts, isDiscard, score, code };\n};\n\n/**\n * Extract results for each competitor from a summary results table.\n *\n * @param element the `<table>` element.\n * @returns the results.\n */\nexport const parseResultsTable = (element: Element): GroupTableParser => {\n  return new GroupTableParser().parse(element);\n};\n","import { cameToStartingArea, checkIsSailedResult } from '../results';\n\nimport { parseResultsTable } from './parse-group-table';\nimport { formatSailedResult, formatScore, formatOrdinal } from './helpers';\n\nimport type { Group, GroupRace } from '../results';\n\nexport const renderGroup = (group: Group) => {\n  for (const competitor of group.competitors) {\n    const { elements, rank, results } = competitor;\n    // Place this in order in the DOM to suit the new ranking.\n    if (elements?.competitor?.parentElement) {\n      elements.competitor.parentElement.insertBefore(elements.competitor, null);\n    }\n    // Update the ranking.\n    if (elements?.rank) {\n      elements.rank.textContent =\n        typeof rank === 'number' ? formatOrdinal(rank) : rank;\n    }\n\n    // Update all the scores in the DOM.\n    for (const result of results) {\n      const sailedResult = checkIsSailedResult(result);\n      if (!sailedResult) {\n        // Skip races not sailed.\n        continue;\n      }\n      result.element.textContent = formatSailedResult(sailedResult);\n    }\n\n    // Check these exist to avoid any problems.\n    if (elements?.net && elements.total) {\n      elements.net.textContent = formatScore(competitor.net);\n      elements.total.textContent = formatScore(competitor.total);\n    }\n  }\n};\n\nexport const parseGroup = (titleElement: Element): Group => {\n  const group: Group = {\n    // Remove 'summary' from the beginning of the id.\n    id: titleElement.id.slice(7),\n    caption: '',\n    title: titleElement.textContent ?? '',\n    competitors: [],\n    qualifiedCount: 0,\n    races: [],\n  };\n\n  let el: Element | null = titleElement;\n  let raceCount = 0;\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    // Look at the next element, stopping when there are no more siblings\n    // or we reach the next title element (which should not happen).\n    el = el.nextElementSibling;\n    if (!el || el.classList.contains('summarytitle')) break;\n\n    if (el.classList.contains('summarycaption')) {\n      // Process the caption.\n      group.caption = el.textContent ?? '';\n    } else if (el.classList.contains('summarytable')) {\n      // Process the results table.\n      const results = parseResultsTable(el);\n      raceCount = results.raceCount;\n      group.qualifiedCount = results.qualifiedCount;\n      group.competitors = results.competitors;\n    }\n  }\n\n  group.races = processRaces(group, raceCount);\n  return group;\n};\n\nconst processRaces = (group: Group, raceCount: number): GroupRace[] => {\n  const races: GroupRace[] = [];\n  // Build results for each race.\n  for (let i = 0; i < raceCount; ++i) {\n    const race: GroupRace = {\n      isSailed: false,\n      countCameToStart: 0,\n    };\n    // Look at each competitor's result for the race.\n    for (const { results } of group.competitors) {\n      const sailedResult = checkIsSailedResult(results[i]);\n\n      if (!sailedResult) {\n        if (race.isSailed) {\n          // If a race is sailed we should have a score for every competitor,\n          // but if we do not we will ignore it.\n        }\n        continue;\n      }\n\n      race.isSailed = true;\n      if (cameToStartingArea(sailedResult.code)) {\n        // Add the competitor to the count of competitors that came to the start area.\n        ++race.countCameToStart;\n      }\n    }\n\n    // races.push(race.isSailed ? new SailedRace(race) : new NotSailedRace());\n    races.push(race);\n  }\n  return races;\n};\n","import { parseGroup } from './group';\n\nimport type { Group } from '../results';\n\nexport interface ParsedResults {\n  groups: Group[];\n}\n\nexport class ResultsHtmlParser {\n  parse(doc: Document) {\n    const parsed: ParsedResults = {\n      groups: [],\n    };\n    const groupTitleElements = doc.querySelectorAll('.summarytitle');\n\n    groupTitleElements.forEach((el) => {\n      const group = parseGroup(el);\n      if (group) {\n        parsed.groups.push(group);\n      }\n    });\n    return parsed;\n  }\n}\n\n/**\n * Parse a results document.\n *\n * @param doc The DOM tree to parse.\n * @returns A parsed tree.\n */\nexport const parseResultsHtml = (doc: Document) => {\n  return new ResultsHtmlParser().parse(doc);\n};\n","import { DNC, DNQ, checkIsSailedResult } from '../results';\n\nimport type { Group } from '../results';\n\n/**\n * Adjust the score for each DNC result to the greater of the number of competitors\n * qualifying for the series and the number that came to the starting area for\n * the race, plus 1.\n *\n * Note that this only recalculates individual race scores, it does NOT\n * recalculate discards or totals.\n *\n * @param group The group to be rescored.\n */\nexport const rescoreQualifiers = (group: Group) => {\n  const { competitors, races, qualifiedCount } = group;\n\n  for (let raceIndex = 0; raceIndex < races.length; ++raceIndex) {\n    const race = races[raceIndex];\n    if (!race.isSailed) {\n      // We shouldn't have to do anything with a race that is not sailed.\n      continue;\n    }\n\n    for (const competitor of competitors) {\n      const result = checkIsSailedResult(competitor.results[raceIndex]);\n      if (result === false) {\n        // We shouldn't have a competitor without a result for a sailed race, but\n        // we will ignore this.\n        continue;\n      }\n\n      if (result.code === DNC) {\n        // Rescore DNC result only.\n        result.score = Math.max(qualifiedCount, race.countCameToStart) + 1;\n      }\n    }\n  }\n};\n\n/**\n * Adjust the score for each DNC result to the greater of the number of competitors\n * qualifying for the series and the number that came to the starting area for\n * the race, plus 1.\n *\n * Note that this only recalculates individual race scores, it does NOT\n * recalculate discards or totals.\n *\n * @param group The group to be rescored.\n */\nexport const rescoreQualifyingRaces = (group: Group) => {\n  const { competitors, races, qualifiedCount } = group;\n\n  for (let raceIndex = 0; raceIndex < races.length; ++raceIndex) {\n    const race = races[raceIndex];\n    if (!race.isSailed) {\n      // We shouldn't have to do anything with a race that is not sailed.\n      continue;\n    }\n\n    let atLeastOneQualifierCame = false;\n    for (const competitor of competitors) {\n      if (!atLeastOneQualifierCame && competitor.rank !== DNQ) {\n        atLeastOneQualifierCame = true;\n      }\n      const result = checkIsSailedResult(competitor.results[raceIndex]);\n      if (result === false) {\n        // We shouldn't have a competitor without a result for a sailed race, but\n        // we will ignore this.\n        continue;\n      }\n\n      if (result.code === DNC) {\n        // Rescore DNC result only.\n        result.score = Math.max(qualifiedCount, race.countCameToStart) + 1;\n      }\n    }\n\n    // @REVISIT need a test to check this works.\n    if (!atLeastOneQualifierCame) {\n      race.isSailed = false;\n    }\n  }\n};\n","/**\n * This is the entry point for the CountOnlyQualifyingRaces effect.\n *\n * There are no exports, this module only has the side-effect of modifying the\n * DOM to reflect rescoring according to the changes to the rules described\n * at [blah](../blah).\n * @module\n */\nimport { version, parseResultsHtml, scoreGroup, renderGroup } from '..';\n\nimport { rescoreQualifyingRaces } from './scoring';\n\nconst addCaption = () => {\n  const $title = document.querySelector('.seriestitle');\n  const caption = document.createElement('div');\n  caption.innerHTML =\n    'DNC scores and races sailed are provisional based on the number of qualifiers.' +\n    '<br><small>Rescored by Count Only Qualifying Races effect v' +\n    version +\n    '</small>';\n  $title?.insertAdjacentElement('afterend', caption);\n};\n\ndocument.addEventListener('DOMContentLoaded', () => {\n  const results = parseResultsHtml(document);\n  for (const group of results.groups) {\n    rescoreQualifyingRaces(group);\n    scoreGroup(group);\n    renderGroup(group);\n  }\n  addCaption();\n});\n"],"names":["DNQ","dncCodes","cameToStartingArea","code","includes","checkIsSailedResult","result","isNotSailed","compareSeriesResults","a","b","rank","difference","net","getDiscardIndexes","scores","number","scoresToDiscard","slice","sort","reverse","discards","lastScore","NaN","lastIndex","score","indexOf","push","scoreGroup","group","competitor","competitors","discardsAllowed","totalScoreTimesTen","results","sailedResult","isDiscard","Math","round","discardIndexes","netScoreTimesTen","index","total","applyDiscardsAndCalculateTotals","recalculateGroupRankings","parseValue","text","parseFloat","formatOrdinal","n","ordinal","formatSailedResult","formatScore","toFixed","GroupTableParser","constructor","this","columns","raceCount","qualifiedCount","parse","tableElement","node","children","nodeName","parseColGroup","parseSummaryRows","parent","className","type","name","parseRaceScore","element","html","innerHTML","parseSummaryRow","elements","colIndex","column","parseRank","textContent","classList","contains","charAt","rawText","Number","isNaN","length","spacePos","isCts","renderGroup","_a","parentElement","insertBefore","processRaces","races","i","race","isSailed","countCameToStart","ResultsHtmlParser","doc","parsed","groups","querySelectorAll","forEach","el","titleElement","id","caption","title","nextElementSibling","_b","parseGroup","rescoreQualifyingRaces","raceIndex","atLeastOneQualifierCame","max","document","addEventListener","$title","querySelector","createElement","insertAdjacentElement","addCaption"],"mappings":"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"}